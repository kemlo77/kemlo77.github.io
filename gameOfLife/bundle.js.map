{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;ACAyC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,4BAA4B,sDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,wBAAwB;AACxB,qBAAqB;AACrB,yBAAyB;AACzB;AACA;AACA;AACA,+BAA+B;AAC/B,qCAAqC;AACrC,2BAA2B;AAC3B,6BAA6B;AAC7B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB;AACpB,mBAAmB;AACnB,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACX8B;AACvB;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA,4BAA4B,WAAW;AACvC,6BAA6B,uCAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjEO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvDwC;AACG;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6CAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qCAAqC;AACrC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAU;AAC7B;AACA;AACA;AACA;AACA,mBAAmB,mDAAU;AAC7B;AACA;;;;;;;;;;;;;;;;ACtH4C;AACrC,yBAAyB,qDAAW;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACd0C;AACU;AACF;AACE;AACJ;AACiB;AACb;AAC7C;AACP;AACA;AACA,wCAAwC,6DAAe;AACvD,sCAAsC,6DAAiB;AACvD,mCAAmC,mDAAU;AAC7C,0CAA0C,0EAAsB;AAChE,sCAAsC,yDAAa;AACnD,wCAAwC,6DAAe;AACvD,gCAAgC,2DAAc;AAC9C;AACA;AACA;;;;;;;;;;;;;;;;ACnB4C;AACrC,8BAA8B,qDAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACR4C;AACrC,6BAA6B,qDAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACR4C;AACrC,8BAA8B,qDAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7F4C;AACrC,qCAAqC,qDAAW;AACvD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpB4D;AAChB;AACrC,4BAA4B,qDAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iEAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzD4C;AACrC,gCAAgC,qDAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;ACnBwC;AACjC;AACP;AACA;AACA,gCAAgC,6CAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACdO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACXyE;AACF;AAC9B;AAClC;AACP;AACA;AACA;AACA,oCAAoC,kDAAM;AAC1C,2BAA2B,+FAAiC;AAC5D,oCAAoC,kDAAM;AAC1C,qCAAqC,kFAAmB;AACxD;AACA;AACA,2BAA2B,+FAAiC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;UCjDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACNqB;AACe;AACD;AACY;AACY;AAC3D,iBAAiB,6CAAI;AACrB,iBAAiB,4CAAI;AACrB,qBAAqB,oEAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://game-of-life-visualized-differently/./src/style.css?e320","webpack://game-of-life-visualized-differently/./src/model/animator.service.ts","webpack://game-of-life-visualized-differently/./src/model/cell.ts","webpack://game-of-life-visualized-differently/./src/model/cellconnection.ts","webpack://game-of-life-visualized-differently/./src/model/grid.ts","webpack://game-of-life-visualized-differently/./src/model/patterns.ts","webpack://game-of-life-visualized-differently/./src/view/canvas/canvas.ts","webpack://game-of-life-visualized-differently/./src/view/cellpainters/agepainter.ts","webpack://game-of-life-visualized-differently/./src/view/cellpainters/cellpainter.ts","webpack://game-of-life-visualized-differently/./src/view/cellpainters/cellpainterfactory.ts","webpack://game-of-life-visualized-differently/./src/view/cellpainters/circularpainter.ts","webpack://game-of-life-visualized-differently/./src/view/cellpainters/classicpainter.ts","webpack://game-of-life-visualized-differently/./src/view/cellpainters/moleculepainter.ts","webpack://game-of-life-visualized-differently/./src/view/cellpainters/neighbourcountpainter.ts","webpack://game-of-life-visualized-differently/./src/view/cellpainters/ribbonpainter.ts","webpack://game-of-life-visualized-differently/./src/view/cellpainters/smoothpainter.ts","webpack://game-of-life-visualized-differently/./src/view/cellpainters/squarecursorpainter.ts","webpack://game-of-life-visualized-differently/./src/view/coordinate.ts","webpack://game-of-life-visualized-differently/./src/view/view.ts","webpack://game-of-life-visualized-differently/webpack/bootstrap","webpack://game-of-life-visualized-differently/webpack/runtime/define property getters","webpack://game-of-life-visualized-differently/webpack/runtime/hasOwnProperty shorthand","webpack://game-of-life-visualized-differently/webpack/runtime/make namespace object","webpack://game-of-life-visualized-differently/./src/main.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","import { patternsMap } from './patterns';\nexport class AnimatorService {\n    constructor(grid) {\n        this._grid = grid;\n    }\n    animatePattern(pattern, posX, posY) {\n        pattern.forEach((row, rowIndex) => {\n            row.forEach((shouldLive, columnIndex) => {\n                if (shouldLive) {\n                    this._grid.cellAt(posX + columnIndex, posY + rowIndex).live();\n                }\n            });\n        });\n    }\n    createPattern(name, posX, posY) {\n        this.animatePattern(patternsMap.get(name), posX, posY);\n    }\n    createCorners() {\n        this._grid.cellAt(0, 0).live();\n        this._grid.cellAt(this._grid.numberOfColumns - 1, this._grid.numberOfRows - 1).live();\n    }\n    createMidpoints() {\n        this._grid.cellAt(this._grid.numberOfColumns / 2, this._grid.numberOfRows / 2).live();\n    }\n}\n","export class Cell {\n    constructor(columnIndex, rowIndex) {\n        this._neighbours = [];\n        this._age = 0;\n        this._columnIndex = 0;\n        this._rowIndex = 0;\n        this._killMe = () => this.die();\n        this._doNothing = () => { return; };\n        this._reviveMe = () => this.live();\n        this._continueLiving = () => this.live();\n        this._plannedFate = this._doNothing;\n        this._columnIndex = columnIndex;\n        this._rowIndex = rowIndex;\n    }\n    get age() { return this._age; }\n    get columnIndex() { return this._columnIndex; }\n    get rowIndex() { return this._rowIndex; }\n    addNeighbour(cell) { this._neighbours.push(cell); }\n    get neigbours() {\n        return this._neighbours;\n    }\n    get numberOfNeighbours() { return this._neighbours.length; }\n    get numberOfLivingNeighbours() { return this.livingNeighbours.length; }\n    get deadNeighbours() { return this._neighbours.filter(cell => cell.isDead); }\n    get livingNeighbours() { return this._neighbours.filter(cell => cell.isAlive); }\n    get orthogonalNeighbours() {\n        return this._neighbours.filter(neigbour => {\n            return this._columnIndex == neigbour.columnIndex || this._rowIndex == neigbour.rowIndex;\n        });\n    }\n    get livingOrthogonalNeighbours() {\n        return this.orthogonalNeighbours.filter(neighbour => neighbour.isAlive);\n    }\n    get diagonalNeighbours() {\n        return this._neighbours.filter(neigbour => {\n            return this._columnIndex !== neigbour.columnIndex && this._rowIndex !== neigbour.rowIndex;\n        });\n    }\n    get livingDiagonalNeighbours() {\n        return this.diagonalNeighbours.filter(neighbour => neighbour.isAlive);\n    }\n    get isAlive() { return this._age > 0; }\n    get isDead() { return this._age == 0; }\n    live() { this._age += 1; }\n    die() { this._age = 0; }\n    toggleLifeDeath() {\n        if (this.isAlive) {\n            this.die();\n        }\n        else {\n            this.live();\n        }\n    }\n    planFate() {\n        if (this.isAlive) {\n            if (this.numberOfLivingNeighbours == 2 || this.numberOfLivingNeighbours == 3) {\n                this._plannedFate = this._continueLiving;\n                return;\n            }\n            else {\n                this._plannedFate = this._killMe;\n                return;\n            }\n        }\n        if (this.isDead && this.numberOfLivingNeighbours == 3) {\n            this._plannedFate = this._reviveMe;\n            return;\n        }\n    }\n    executeFate() {\n        this._plannedFate();\n        this._plannedFate = this._doNothing;\n    }\n}\n","export class CellConnection {\n    constructor(cell1, cell2) {\n        this._cell1 = cell1;\n        this._cell2 = cell2;\n    }\n    get cell1() {\n        return this._cell1;\n    }\n    get cell2() {\n        return this._cell2;\n    }\n}\n","import { Cell } from './cell';\nexport class Grid {\n    constructor(columns, rows) {\n        this._grid = this.generateColumnOfRowOfCells(columns, rows);\n        this.connectCellsWithNeighbours();\n    }\n    generateColumnOfRowOfCells(width, height) {\n        const columnOfRows = [];\n        for (let y = 0; y < height; y++) {\n            const row = [];\n            for (let x = 0; x < width; x++) {\n                row.push(new Cell(x, y));\n            }\n            columnOfRows.push(row);\n        }\n        return columnOfRows;\n    }\n    connectCellsWithNeighbours() {\n        this.allCells.forEach(currentCell => {\n            this.allCells\n                .filter(cell => cell !== currentCell)\n                .filter(cell => Math.abs(currentCell.columnIndex - cell.columnIndex) <= 1)\n                .filter(cell => Math.abs(currentCell.rowIndex - cell.rowIndex) <= 1)\n                .forEach(cell => currentCell.addNeighbour(cell));\n        });\n    }\n    get numberOfColumns() {\n        return this._grid[0].length;\n    }\n    get numberOfRows() {\n        return this._grid.length;\n    }\n    cellAt(x, y) {\n        return this._grid[y][x];\n    }\n    get allCells() {\n        return this._grid.flat();\n    }\n    get allLiveCells() {\n        return this.allCells.filter(cell => cell.isAlive);\n    }\n    get clustersOfLiveCells() {\n        const clusterArray = [];\n        const alreadyChecked = new Set();\n        for (const livingCell of this.allLiveCells) {\n            if (alreadyChecked.has(livingCell)) {\n                continue;\n            }\n            const cluster = [];\n            const candidates = [livingCell];\n            while (candidates.length > 0) {\n                const candidate = candidates.pop();\n                alreadyChecked.add(livingCell);\n                cluster.push(candidate);\n                candidate.livingNeighbours.forEach(neigbour => {\n                    if (!alreadyChecked.has(neigbour)) {\n                        alreadyChecked.add(neigbour);\n                        candidates.push(neigbour);\n                    }\n                });\n            }\n            clusterArray.push(cluster);\n        }\n        return clusterArray;\n    }\n}\n","export const pentaDecathlon = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0],\n    [1, 1, 0, 1, 1, 1, 1, 0, 1, 1],\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]\n];\nexport const zHexomino = [\n    [1, 1, 0],\n    [0, 1, 0],\n    [0, 1, 0],\n    [0, 1, 1]\n];\nexport const ship = [\n    [1, 1, 0],\n    [1, 0, 1],\n    [0, 1, 1]\n];\nexport const toad = [\n    [1, 1, 1, 0],\n    [0, 1, 1, 1]\n];\nexport const lightweightSpaceship = [\n    [1, 0, 0, 1, 0],\n    [0, 0, 0, 0, 1],\n    [1, 0, 0, 0, 1],\n    [0, 1, 1, 1, 1]\n];\nexport const glider = [\n    [0, 0, 1],\n    [1, 0, 1],\n    [0, 1, 1]\n];\nexport const oscillatingPulsar = [\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n    [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1],\n    [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0],\n    [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n    [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0],\n    [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\n];\nexport const patternsMap = new Map();\npatternsMap.set('pentaDecathlon', pentaDecathlon);\npatternsMap.set('zHexomino', zHexomino);\npatternsMap.set('ship', ship);\npatternsMap.set('toad', toad);\npatternsMap.set('lightweightSpaceship', lightweightSpaceship);\npatternsMap.set('glider', glider);\npatternsMap.set('oscillatingPulsar', oscillatingPulsar);\n","import { Cell } from '../../model/cell';\nimport { Coordinate } from '../coordinate';\nexport class Canvas {\n    constructor(canvasId, grid) {\n        this._cellWidth = 20;\n        this._xOffset = 0;\n        this._yOffset = 0;\n        this.black = 'rgba(0,0,0,1)';\n        this._canvasElement = document.getElementById(canvasId);\n        this._canvasCtx = this._canvasElement.getContext('2d');\n        this._grid = grid;\n    }\n    get width() {\n        return this._width;\n    }\n    get height() {\n        return this._height;\n    }\n    get cellWidth() {\n        return this._cellWidth;\n    }\n    get thinLineWidth() {\n        return this.cellWidth * 0.1;\n    }\n    get mediumLineWidth() {\n        return this.cellWidth * 0.5;\n    }\n    get wideLineWidth() {\n        return this.cellWidth;\n    }\n    clearTheCanvas() {\n        this._canvasCtx.clearRect(0, 0, this._width, this._height);\n    }\n    updateCanvasWhenWindowChanges() {\n        this._width = window.innerWidth - 32;\n        this._height = window.innerHeight - 16;\n        this._canvasElement.width = this._width;\n        this._canvasElement.height = this._height;\n        if (this._width > this._height) {\n            this._cellWidth = this._width / this._grid.numberOfColumns;\n            this._yOffset = (this._grid.numberOfRows * this._cellWidth - this._height) / 2;\n            this._xOffset = 0;\n        }\n        else {\n            this._cellWidth = this._height / this._grid.numberOfRows;\n            this._yOffset = 0;\n            this._xOffset = (this._grid.numberOfColumns * this._cellWidth - this._width) / 2;\n        }\n    }\n    getCellAttCoordinate(coordinate) {\n        const xOutsideCanvas = 0 > coordinate.x || coordinate.x >= this._width;\n        const yOutsideCanvas = 0 > coordinate.y || coordinate.y >= this._height;\n        if (xOutsideCanvas || yOutsideCanvas) {\n            return new Cell(0, 0);\n        }\n        const columnIndex = Math.floor((coordinate.x + this._xOffset) / this.cellWidth);\n        const rowIndex = Math.floor((coordinate.y + this._yOffset) / this.cellWidth);\n        return this._grid.cellAt(columnIndex, rowIndex);\n    }\n    paintLineBetweenCells(cell1, cell2, width = this.thinLineWidth, color = this.black, offset = false) {\n        let shadowOffset = 0;\n        if (offset) {\n            shadowOffset = this.cellWidth * 0.1;\n        }\n        this._canvasCtx.strokeStyle = color;\n        const centerOfCell1 = this.centerOfCell(cell1);\n        const centerOfCell2 = this.centerOfCell(cell2);\n        this._canvasCtx.lineWidth = width;\n        this._canvasCtx.lineCap = 'round';\n        this._canvasCtx.beginPath();\n        this._canvasCtx.moveTo(centerOfCell1.x + shadowOffset, centerOfCell1.y + shadowOffset);\n        this._canvasCtx.lineTo(centerOfCell2.x + shadowOffset, centerOfCell2.y + shadowOffset);\n        this._canvasCtx.stroke();\n    }\n    paintCellsAsHollowDots(cells, innerColor) {\n        this.paintCircles(cells, this.black, this.cellWidth * 0.64, false);\n        this.paintCircles(cells, innerColor, this.cellWidth * 0.4, false);\n    }\n    paintCircles(cells, color, diameter = this.cellWidth, offset = false) {\n        let shadowOffset = 0;\n        if (offset) {\n            shadowOffset = this.cellWidth * 0.1;\n        }\n        const radius = diameter / 2;\n        this._canvasCtx.fillStyle = color;\n        cells.forEach(cell => {\n            const center = this.centerOfCell(cell);\n            this._canvasCtx.beginPath();\n            this._canvasCtx.arc(center.x + shadowOffset, center.y + shadowOffset, radius, 0, 2 * Math.PI);\n            this._canvasCtx.fill();\n        });\n    }\n    paintSquares(cells, color) {\n        const padding = 1;\n        this._canvasCtx.fillStyle = color;\n        this._canvasCtx.beginPath(); //varför måste jag ha med detta för att färgändring ska slå igenom\n        this._canvasCtx.stroke(); // dito\n        const squareWidth = this.cellWidth - 2 * padding;\n        cells.forEach(cell => {\n            const corner = this.upperLeftCornerOfCell(cell);\n            this._canvasCtx.rect(corner.x + padding, corner.y + padding, squareWidth, squareWidth);\n            this._canvasCtx.fill();\n        });\n    }\n    clearSquare(cell) {\n        const position = this.upperLeftCornerOfCell(cell);\n        this._canvasCtx.clearRect(position.x, position.y, this.cellWidth, this.cellWidth);\n    }\n    upperLeftCornerOfCell(cell) {\n        const xPart = cell.columnIndex * this.cellWidth - this._xOffset;\n        const yPart = cell.rowIndex * this.cellWidth - this._yOffset;\n        return new Coordinate(xPart, yPart);\n    }\n    centerOfCell(cell) {\n        const xPart = (cell.columnIndex * this.cellWidth + this.cellWidth / 2) - this._xOffset;\n        const yPart = (cell.rowIndex * this.cellWidth + this.cellWidth / 2) - this._yOffset;\n        return new Coordinate(xPart, yPart);\n    }\n}\n","import { CellPainter } from './cellpainter';\nexport class AgePainter extends CellPainter {\n    plotCells(grid) {\n        grid.allLiveCells.forEach(cell => {\n            this.canvas.paintSquares([cell], this.colorGivenTheAgeOfCell(cell));\n        });\n    }\n    colorGivenTheAgeOfCell(cell) {\n        switch (cell.age) {\n            case 1: return 'rgba(170,190,170,1)';\n            case 2: return 'rgba(150,170,150,1)';\n            case 3: return 'rgba(120,130,120,1)';\n            case 4: return 'rgba(90,110,90,1)';\n            case 5: return 'rgba(70,90,70,1)';\n            case 6: return 'rgba(50,70,50,1)';\n            case 7: return 'rgba(30,50,30,1)';\n            case 8: return 'rgba(10,30,10,1)';\n            default: return 'rgba(0,0,0,1)';\n        }\n    }\n}\n","export class CellPainter {\n    constructor(canvas) {\n        this.white = 'rgba(255,255,255,1)';\n        this.black = 'rgba(0,0,0,1)';\n        this.green = 'rgba(0,255,0,1)';\n        this.gray = 'rgba(128,128,128,1)';\n        this.orange = 'rgba(255,127,0,1)';\n        this.yellow = 'rgba(255,255,0,1)';\n        this.lightBlue = 'rgba(100,100,255,1)';\n        this.canvas = canvas;\n    }\n    clearTheCanvas() {\n        this.canvas.clearTheCanvas();\n    }\n}\n","import { AgePainter } from './agepainter';\nimport { CircularPainter } from './circularpainter';\nimport { ClassicPainter } from './classicpainter';\nimport { MoleculePainter } from './moleculepainter';\nimport { RibbonPainter } from './ribbonpainter';\nimport { NeighboursCountPainter } from './neighbourcountpainter';\nimport { SmoothCellPainter } from './smoothpainter';\nexport class CellPainterFactory {\n    static getCellPainter(painterType, canvas) {\n        switch (painterType) {\n            case 'circular': return new CircularPainter(canvas);\n            case 'smooth': return new SmoothCellPainter(canvas);\n            case 'age': return new AgePainter(canvas);\n            case 'neighbours': return new NeighboursCountPainter(canvas);\n            case 'ribbon': return new RibbonPainter(canvas);\n            case 'molecule': return new MoleculePainter(canvas);\n            default: return new ClassicPainter(canvas);\n        }\n    }\n}\n","import { CellPainter } from './cellpainter';\nexport class CircularPainter extends CellPainter {\n    constructor(canvas) {\n        super(canvas);\n    }\n    plotCells(grid) {\n        this.canvas.paintCircles(grid.allLiveCells, this.black);\n    }\n}\n","import { CellPainter } from './cellpainter';\nexport class ClassicPainter extends CellPainter {\n    constructor(canvas) {\n        super(canvas);\n    }\n    plotCells(grid) {\n        this.canvas.paintSquares(grid.allLiveCells, this.black);\n    }\n}\n","import { CellPainter } from './cellpainter';\nexport class MoleculePainter extends CellPainter {\n    constructor(canvas) {\n        super(canvas);\n    }\n    plotCells(grid) {\n        const livingCells = grid.allLiveCells;\n        //orthogonal connections\n        livingCells\n            .forEach(cell => {\n            cell.livingOrthogonalNeighbours\n                .forEach(neighbour => {\n                this.canvas.paintLineBetweenCells(cell, neighbour);\n            });\n        });\n        this.cellsWithNoLivingOrthogonalNeihbours(livingCells)\n            .forEach(cell => {\n            cell.livingDiagonalNeighbours\n                .forEach(neighbour => {\n                this.canvas.paintLineBetweenCells(cell, neighbour);\n            });\n        });\n        this.cellsWithOneLivingOrthogonalNeihbours(livingCells).forEach(cell => {\n            cell.livingDiagonalNeighbours\n                .forEach(neighbour => {\n                if (this.cellsHaveNoCommonLivingOrthogonalNeighbours(cell, neighbour)) {\n                    this.canvas.paintLineBetweenCells(cell, neighbour);\n                }\n            });\n        });\n        this.canvas.paintCellsAsHollowDots(livingCells, this.gray);\n        this.canvas.paintCellsAsHollowDots(this.cellsWithNoLivingNeighbours(livingCells), this.yellow);\n        this.canvas.paintCellsAsHollowDots(this.cellsWithOneLivingOrthogonalNeighbour(livingCells), this.green);\n        this.cellsWithOneLivingOrthogonalNeihbours(livingCells).forEach(cell => {\n            cell.livingDiagonalNeighbours\n                .forEach(neighbour => {\n                if (this.cellsHaveNoCommonLivingOrthogonalNeighbours(cell, neighbour)) {\n                    this.canvas.paintCellsAsHollowDots([cell, neighbour], this.gray);\n                }\n            });\n        });\n        this.canvas.paintCellsAsHollowDots(this.cellsWithOneLivingDiagonalNeighbour(livingCells), this.lightBlue);\n        this.canvas.paintCellsAsHollowDots(this.cellsWithTwoDiagonalNeighboursNotOnALine(livingCells), this.orange);\n        this.canvas.paintCellsAsHollowDots(this.cellsWithTwoOrthogonalNeighbousNotOnALine(livingCells), this.orange);\n    }\n    cellsWithTwoOrthogonalNeighbousNotOnALine(cells) {\n        return cells\n            .filter(cell => cell.livingNeighbours.length == 2)\n            .filter(cell => cell.livingOrthogonalNeighbours.length == 2)\n            .filter(cell => {\n            const neighbours = cell.livingOrthogonalNeighbours;\n            const n1 = neighbours[0];\n            const n2 = neighbours[1];\n            return n1.columnIndex !== n2.columnIndex && n1.rowIndex !== n2.rowIndex;\n        });\n    }\n    cellsWithTwoDiagonalNeighboursNotOnALine(cells) {\n        return cells\n            .filter(cell => cell.livingNeighbours.length == 2)\n            .filter(cell => cell.livingDiagonalNeighbours.length == 2)\n            .filter(cell => {\n            const neighbours = cell.livingDiagonalNeighbours;\n            const n1 = neighbours[0];\n            const n2 = neighbours[1];\n            return n1.columnIndex == n2.columnIndex || n1.rowIndex == n2.rowIndex;\n        });\n    }\n    cellsWithNoLivingNeighbours(cells) {\n        return cells.filter(cell => cell.livingNeighbours.length == 0);\n    }\n    cellsWithOneLivingOrthogonalNeighbour(cells) {\n        return cells\n            //.filter(cell => cell.livingNeighbours.length == 1)\n            .filter(cell => cell.livingOrthogonalNeighbours.length == 1);\n    }\n    cellsWithOneLivingDiagonalNeighbour(cells) {\n        return cells\n            .filter(cell => cell.livingNeighbours.length == 1)\n            .filter(cell => cell.livingDiagonalNeighbours.length == 1);\n    }\n    cellsHaveNoCommonLivingOrthogonalNeighbours(cell1, cell2) {\n        const commonLivingOrthogonalCells = cell1.livingOrthogonalNeighbours\n            .filter(c1 => cell2.livingOrthogonalNeighbours.some(c2 => c1 == c2));\n        return commonLivingOrthogonalCells.length == 0;\n    }\n    cellsWithNoLivingOrthogonalNeihbours(cells) {\n        return cells\n            .filter(cell => cell.livingOrthogonalNeighbours.length == 0);\n    }\n    cellsWithOneLivingOrthogonalNeihbours(cells) {\n        return cells\n            .filter(cell => cell.livingOrthogonalNeighbours.length == 1);\n    }\n}\n","import { CellPainter } from './cellpainter';\nexport class NeighboursCountPainter extends CellPainter {\n    plotCells(grid) {\n        grid.allLiveCells.forEach(cell => {\n            this.canvas.paintSquares([cell], this.colorGivenNumberOfNeighboursToOfCell(cell));\n        });\n    }\n    colorGivenNumberOfNeighboursToOfCell(cell) {\n        switch (cell.livingNeighbours.length) {\n            case 0: return 'rgba(170,190,170,1)';\n            case 1: return 'rgba(150,170,150,1)';\n            case 2: return 'rgba(120,130,120,1)';\n            case 3: return 'rgba(90,110,90,1)';\n            case 4: return 'rgba(70,90,70,1)';\n            case 5: return 'rgba(50,70,50,1)';\n            case 6: return 'rgba(30,50,30,1)';\n            case 7: return 'rgba(10,30,10,1)';\n            default: return 'rgba(0,0,0,1)';\n        }\n    }\n}\n","import { CellConnection } from '../../model/cellconnection';\nimport { CellPainter } from './cellpainter';\nexport class RibbonPainter extends CellPainter {\n    plotCells(grid) {\n        grid.clustersOfLiveCells.forEach(cluster => {\n            const randomConnections = this.generateMazelikeRandomCellConnections(cluster);\n            randomConnections.forEach(connection => {\n                this.canvas.paintLineBetweenCells(connection.cell1, connection.cell2, this.canvas.mediumLineWidth, this.gray, true);\n                this.canvas.paintLineBetweenCells(connection.cell1, connection.cell2, this.canvas.mediumLineWidth, this.green);\n            });\n        });\n        const lonleyCells = grid.allLiveCells.filter(cell => cell.livingNeighbours.length == 0);\n        this.canvas.paintCircles(lonleyCells, this.gray, this.canvas.mediumLineWidth, true);\n        this.canvas.paintCircles(lonleyCells, this.green, this.canvas.mediumLineWidth, false);\n    }\n    generateMazelikeRandomCellConnections(cluster) {\n        const cellConnections = [];\n        const cellsToConnect = cluster.length;\n        const connectedCells = new Set();\n        const connectionTrail = [];\n        const startCell = radomCellInArray(cluster);\n        connectCell(startCell);\n        while (cellsToConnect > connectedCells.size) {\n            while (cellHasNoUnconnectedNeigbours(currentCell()) && connectedTrailNotEmpty()) {\n                stepBackwards();\n            }\n            const randomNeighbour = randomUnconnectedNeighbour(currentCell());\n            cellConnections.push(new CellConnection(currentCell(), randomNeighbour));\n            connectCell(randomNeighbour);\n        }\n        return cellConnections;\n        function currentCell() {\n            const currentCell = connectionTrail[connectionTrail.length - 1];\n            return currentCell;\n        }\n        function connectedTrailNotEmpty() {\n            return connectionTrail.length != 0;\n        }\n        function cellHasNoUnconnectedNeigbours(cell) {\n            return cell.livingNeighbours.every(neigbour => connectedCells.has(neigbour));\n        }\n        function stepBackwards() {\n            connectionTrail.pop();\n        }\n        function randomUnconnectedNeighbour(cell) {\n            const unvisitedNeighbours = cell.livingNeighbours\n                .filter(neighbour => !connectedCells.has(neighbour));\n            return radomCellInArray(unvisitedNeighbours);\n        }\n        function connectCell(cell) {\n            connectedCells.add(cell);\n            connectionTrail.push(cell);\n        }\n        function radomCellInArray(cells) {\n            return cells[Math.floor(Math.random() * cells.length)];\n        }\n    }\n}\n","import { CellPainter } from './cellpainter';\nexport class SmoothCellPainter extends CellPainter {\n    plotCells(grid) {\n        const livingCells = grid.allLiveCells;\n        livingCells.forEach(livingCell => {\n            livingCell.livingNeighbours\n                .forEach(livingNeighbourCell => {\n                this.canvas.paintLineBetweenCells(livingCell, livingNeighbourCell, this.canvas.wideLineWidth);\n            });\n        });\n        livingCells.forEach(livingCell => {\n            livingCell.deadNeighbours\n                .filter(deadCell => deadCell.livingOrthogonalNeighbours.length >= 3)\n                .forEach(deadCell => {\n                this.canvas.paintCircles([deadCell], this.white);\n            });\n        });\n        this.canvas.paintCircles(livingCells, this.black);\n    }\n}\n","import { Cell } from '../../model/cell';\nexport class SquareCursorPainter {\n    constructor(canvas) {\n        this.transparentGreen = 'rgba(255,127,0,0.6)';\n        this.previousCell = new Cell(0, 0);\n        this.canvas = canvas;\n    }\n    clearThePreviousCellOnCanvas() {\n        this.canvas.clearSquare(this.previousCell);\n    }\n    colorCellOnMousePosition(cell) {\n        this.canvas.paintSquares([cell], this.transparentGreen);\n        this.previousCell = cell;\n    }\n}\n","export class Coordinate {\n    constructor(x, y) {\n        this._x = x;\n        this._y = y;\n    }\n    get x() {\n        return this._x;\n    }\n    get y() {\n        return this._y;\n    }\n}\n","import { SquareCursorPainter } from './cellpainters/squarecursorpainter';\nimport { CellPainterFactory } from './cellpainters/cellpainterfactory';\nimport { Canvas } from './canvas/canvas';\nexport class View {\n    constructor(grid) {\n        this.delayedAdjustCanvas = this.debounce(() => this.adjustCanvas(), 500);\n        this.grid = grid;\n        this.backgroundCanvas = new Canvas('gridLayer', grid);\n        this.cellPainter = CellPainterFactory.getCellPainter('smooth', this.backgroundCanvas);\n        this.foregroundCanvas = new Canvas('foreground', grid);\n        this.foregroundPainter = new SquareCursorPainter(this.foregroundCanvas);\n    }\n    changePainter(cellPaintertype) {\n        this.cellPainter = CellPainterFactory.getCellPainter(cellPaintertype, this.backgroundCanvas);\n    }\n    redrawGrid() {\n        this.cellPainter.clearTheCanvas();\n        this.cellPainter.plotCells(this.grid);\n    }\n    drawMouseCellPosition(position) {\n        const cellAtMousePosition = this.getCellAtCoordinate(position);\n        this.foregroundPainter.colorCellOnMousePosition(cellAtMousePosition);\n    }\n    removePreviousMouseCellPosition() {\n        this.foregroundPainter.clearThePreviousCellOnCanvas();\n    }\n    getCellAtCoordinate(coordinate) {\n        return this.foregroundCanvas.getCellAttCoordinate(coordinate);\n    }\n    adjustCanvas() {\n        this.backgroundCanvas.updateCanvasWhenWindowChanges();\n        this.foregroundCanvas.updateCanvasWhenWindowChanges();\n        this.setTheHeightOfTheDiv(this.foregroundCanvas.height);\n        this.redrawGrid();\n    }\n    setTheHeightOfTheDiv(newHeight) {\n        const theDivThatHoldsCanvases = document.querySelector('div#viewport');\n        theDivThatHoldsCanvases.style.height = newHeight + 'px';\n    }\n    debounce(func, wait) {\n        let timeoutID;\n        return function (...args) {\n            clearTimeout(timeoutID);\n            const context = this;\n            timeoutID = window.setTimeout(() => {\n                func.apply(context, args);\n            }, wait);\n        };\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import './style.css';\nimport { Grid } from './model/grid';\nimport { View } from './view/view';\nimport { Coordinate } from './view/coordinate';\nimport { AnimatorService } from './model/animator.service';\nconst grid = new Grid(60, 60);\nconst view = new View(grid);\nconst animator = new AnimatorService(grid);\nlet running = false;\nlet handle;\nanimator.createPattern('glider', 35, 14);\nanimator.createPattern('zHexomino', 12, 27);\nanimator.createPattern('lightweightSpaceship', 12, 42);\nanimator.createPattern('pentaDecathlon', 13, 16);\nanimator.createPattern('toad', 45, 17);\nanimator.createCorners();\nanimator.createPattern('ship', 43, 35);\nanimator.createPattern('oscillatingPulsar', 23, 23);\nfunction toggleRunning() {\n    if (running) {\n        running = false;\n        clearInterval(handle);\n    }\n    else {\n        running = true;\n        handle = setInterval(() => takeAStep(), 500);\n    }\n}\nfunction takeAStep() {\n    evolveAllCellsInGrid();\n    view.redrawGrid();\n}\nfunction evolveAllCellsInGrid() {\n    grid.allCells.forEach(cell => cell.planFate());\n    grid.allCells.forEach(cell => cell.executeFate());\n}\nfunction changePainter(cellPaintertype) {\n    view.changePainter(cellPaintertype);\n    view.redrawGrid();\n}\nfunction canvasLeftClicked(event, canvasId) {\n    const coordinate = getMouseCoordinate(event, canvasId);\n    view.getCellAtCoordinate(coordinate).toggleLifeDeath();\n    view.redrawGrid();\n}\nfunction getMouseCoordinate(event, elementId) {\n    const rect = document.getElementById(elementId).getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    return new Coordinate(x, y);\n}\nfunction canvasMouseMovement(event, canvasId) {\n    const mousePosition = getMouseCoordinate(event, canvasId);\n    view.removePreviousMouseCellPosition();\n    view.drawMouseCellPosition(mousePosition);\n}\nfunction canvasMouseOut() {\n    view.removePreviousMouseCellPosition();\n}\nfunction killAll() {\n    const reallyKillAll = confirm('Do you want to kill every cell?');\n    if (reallyKillAll) {\n        killAllCellsInGrid();\n        view.redrawGrid();\n    }\n}\nfunction killAllCellsInGrid() {\n    grid.allCells.forEach(cell => cell.die());\n}\nfunction keyPressed(event) {\n    switch (event.key.toLowerCase()) {\n        case 'w':\n            toggleRunning();\n            break;\n        case 'e':\n            takeAStep();\n            break;\n        case 'r':\n            changePainter('ribbon');\n            break;\n        case 'a':\n            changePainter('age');\n            break;\n        case 's':\n            changePainter('smooth');\n            break;\n        case 'd':\n            changePainter('circular');\n            break;\n        case 'f':\n            changePainter('molecule');\n            break;\n        case 'x':\n            killAll();\n            break;\n        case 'c':\n            changePainter('classic');\n            break;\n        case 'v':\n            changePainter('neighbours');\n            break;\n    }\n}\ndocument.getElementById('stepButton').addEventListener('click', () => takeAStep());\ndocument.getElementById('classicButton').addEventListener('click', () => changePainter('classic'));\ndocument.getElementById('circularButton').addEventListener('click', () => changePainter('circular'));\ndocument.getElementById('smoothButton').addEventListener('click', () => changePainter('smooth'));\ndocument.getElementById('cellAgeButton').addEventListener('click', () => changePainter('age'));\ndocument.getElementById('neigbourcountButton').addEventListener('click', () => changePainter('neighbours'));\ndocument.getElementById('ribbonButton').addEventListener('click', () => changePainter('ribbon'));\ndocument.getElementById('moleculeButton').addEventListener('click', () => changePainter('molecule'));\ndocument.getElementById('startStopButton').addEventListener('click', () => toggleRunning());\ndocument.getElementById('killAllButton').addEventListener('click', () => killAll());\nconst foreground = document.getElementById('foreground');\nforeground.addEventListener('click', (event) => canvasLeftClicked(event, event.target.id));\nforeground.addEventListener('mousemove', (event) => canvasMouseMovement(event, event.target.id));\nforeground.addEventListener('mouseout', () => canvasMouseOut());\ndocument.addEventListener('keydown', (event) => keyPressed(event));\naddEventListener('load', () => view.adjustCanvas());\naddEventListener('resize', () => view.delayedAdjustCanvas());\n"],"names":[],"sourceRoot":""}