{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;;;;;ACAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,wBAAwB;AACxB,qBAAqB;AACrB,yBAAyB;AACzB;AACA;AACA;AACA,+BAA+B;AAC/B,qCAAqC;AACrC,2BAA2B;AAC3B,6BAA6B;AAC7B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB;AACpB,mBAAmB;AACnB,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACX8B;AACvB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA,4BAA4B,WAAW;AACvC,6BAA6B,uCAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxE2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oCAAoC;AACpC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mBAAmB,mDAAU;AAC7B;AACA;AACA;AACA;AACA,mBAAmB,mDAAU;AAC7B;AACA;;;;;;;;;;;;;;;;ACjFgD;AACzC,6BAA6B,yDAAa;AACjD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACpBkD;AACU;AACF;AACN;AACJ;AACiB;AACb;AACpD;AACO;AACP;AACA;AACA,wCAAwC,qEAAmB;AAC3D,sCAAsC,6DAAiB;AACvD,mCAAmC,2DAAc;AACjD,0CAA0C,0EAAsB;AAChE,sCAAsC,yDAAa;AACnD,wCAAwC,6DAAe;AACvD,gCAAgC,mEAAkB;AAClD;AACA;AACA;;;;;;;;;;;;;;;;ACpBgD;AACzC,kCAAkC,yDAAa;AACtD;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLgD;AACzC,iCAAiC,yDAAa;AACrD;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLgD;AACzC,8BAA8B,yDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1FgD;AACzC,qCAAqC,yDAAa;AACzD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpB4D;AACZ;AACzC,4BAA4B,yDAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iEAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzDgD;AACzC,gCAAgC,yDAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;ACnBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACXiE;AAC1D;AACP;AACA,gCAAgC,0EAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCZA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACNqB;AACe;AACD;AAC2C;AAC/B;AAC/C,iBAAiB,6CAAI;AACrB,iBAAiB,4CAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sGAAkC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://game-of-life/./src/style.css?e320","webpack://game-of-life/./src/model/cell.ts","webpack://game-of-life/./src/model/cellconnection.ts","webpack://game-of-life/./src/model/grid.ts","webpack://game-of-life/./src/view/cellpainters/canvaspainter.ts","webpack://game-of-life/./src/view/cellpainters/cellagepainter.ts","webpack://game-of-life/./src/view/cellpainters/cellpainterprovider.ts","webpack://game-of-life/./src/view/cellpainters/circularcellpainter.ts","webpack://game-of-life/./src/view/cellpainters/classiccellpainter.ts","webpack://game-of-life/./src/view/cellpainters/moleculepainter.ts","webpack://game-of-life/./src/view/cellpainters/neighbourcountpainter.ts","webpack://game-of-life/./src/view/cellpainters/ribbonpainter.ts","webpack://game-of-life/./src/view/cellpainters/smoothpainter.ts","webpack://game-of-life/./src/view/coordinate.ts","webpack://game-of-life/./src/view/view.ts","webpack://game-of-life/webpack/bootstrap","webpack://game-of-life/webpack/runtime/define property getters","webpack://game-of-life/webpack/runtime/hasOwnProperty shorthand","webpack://game-of-life/webpack/runtime/make namespace object","webpack://game-of-life/./src/main.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","export class Cell {\n    constructor(columnIndex, rowIndex) {\n        this._neighbours = [];\n        this._age = 0;\n        this._columnIndex = 0;\n        this._rowIndex = 0;\n        this._killMe = () => this.die();\n        this._doNothing = () => { return; };\n        this._reviveMe = () => this.live();\n        this._continueLiving = () => this.live();\n        this._plannedFate = this._doNothing;\n        this._columnIndex = columnIndex;\n        this._rowIndex = rowIndex;\n    }\n    get age() { return this._age; }\n    get columnIndex() { return this._columnIndex; }\n    get rowIndex() { return this._rowIndex; }\n    addNeighbour(cell) { this._neighbours.push(cell); }\n    get neigbours() {\n        return this._neighbours;\n    }\n    get numberOfNeighbours() { return this._neighbours.length; }\n    get numberOfLivingNeighbours() { return this.livingNeighbours.length; }\n    get deadNeighbours() { return this._neighbours.filter(cell => cell.isDead); }\n    get livingNeighbours() { return this._neighbours.filter(cell => cell.isAlive); }\n    get orthogonalNeighbours() {\n        return this._neighbours.filter(neigbour => {\n            return this._columnIndex == neigbour.columnIndex || this._rowIndex == neigbour.rowIndex;\n        });\n    }\n    get livingOrthogonalNeighbours() {\n        return this.orthogonalNeighbours.filter(neighbour => neighbour.isAlive);\n    }\n    get diagonalNeighbours() {\n        return this._neighbours.filter(neigbour => {\n            return this._columnIndex !== neigbour.columnIndex && this._rowIndex !== neigbour.rowIndex;\n        });\n    }\n    get livingDiagonalNeighbours() {\n        return this.diagonalNeighbours.filter(neighbour => neighbour.isAlive);\n    }\n    get isAlive() { return this._age > 0; }\n    get isDead() { return this._age == 0; }\n    live() { this._age += 1; }\n    die() { this._age = 0; }\n    toggleLifeDeath() {\n        if (this.isAlive) {\n            this.die();\n        }\n        else {\n            this.live();\n        }\n    }\n    planFate() {\n        if (this.isAlive) {\n            if (this.numberOfLivingNeighbours == 2 || this.numberOfLivingNeighbours == 3) {\n                this._plannedFate = this._continueLiving;\n                return;\n            }\n            else {\n                this._plannedFate = this._killMe;\n                return;\n            }\n        }\n        if (this.isDead && this.numberOfLivingNeighbours == 3) {\n            this._plannedFate = this._reviveMe;\n            return;\n        }\n    }\n    executeFate() {\n        this._plannedFate();\n        this._plannedFate = this._doNothing;\n    }\n}\n","export class CellConnection {\n    constructor(cell1, cell2) {\n        this._cell1 = cell1;\n        this._cell2 = cell2;\n    }\n    get cell1() {\n        return this._cell1;\n    }\n    get cell2() {\n        return this._cell2;\n    }\n}\n","import { Cell } from './cell';\nexport class Grid {\n    constructor(width, height) {\n        this._grid = this.generateColumnOfRowOfCells(width, height);\n        this.connectCellsWithNeighbours();\n    }\n    get width() {\n        return this._grid[0].length;\n    }\n    get height() {\n        return this._grid.length;\n    }\n    cellAt(x, y) {\n        return this._grid[y][x];\n    }\n    get allCells() {\n        return this._grid.flat();\n    }\n    get allLiveCells() {\n        return this.allCells.filter(cell => cell.isAlive);\n    }\n    get clusters() {\n        const clusterArray = [];\n        const alreadyChecked = new Set();\n        for (const livingCell of this.allLiveCells) {\n            if (alreadyChecked.has(livingCell)) {\n                continue;\n            }\n            const cluster = [];\n            const candidates = [livingCell];\n            while (candidates.length > 0) {\n                const candidate = candidates.pop();\n                alreadyChecked.add(livingCell);\n                cluster.push(candidate);\n                candidate.livingNeighbours.forEach(neigbour => {\n                    if (!alreadyChecked.has(neigbour)) {\n                        alreadyChecked.add(neigbour);\n                        candidates.push(neigbour);\n                    }\n                });\n            }\n            clusterArray.push(cluster);\n        }\n        return clusterArray;\n    }\n    generateColumnOfRowOfCells(width, height) {\n        const columnOfRows = [];\n        for (let y = 0; y < height; y++) {\n            const row = [];\n            for (let x = 0; x < width; x++) {\n                row.push(new Cell(x, y));\n            }\n            columnOfRows.push(row);\n        }\n        return columnOfRows;\n    }\n    connectCellsWithNeighbours() {\n        this.allCells.forEach(currentCell => {\n            this.allCells\n                .filter(cell => cell !== currentCell)\n                .filter(cell => Math.abs(currentCell.columnIndex - cell.columnIndex) <= 1)\n                .filter(cell => Math.abs(currentCell.rowIndex - cell.rowIndex) <= 1)\n                .forEach(cell => currentCell.addNeighbour(cell));\n        });\n    }\n    evolve() {\n        this.allCells.forEach(cell => cell.planFate());\n        this.allCells.forEach(cell => cell.executeFate());\n    }\n    killAll() {\n        this.allCells.forEach(cell => cell.die());\n    }\n}\n","import { Coordinate } from '../coordinate';\nexport class CanvasPainter {\n    constructor() {\n        this.canvasElement = document.getElementById('myCanvas');\n        this.canvasCtx = this.canvasElement.getContext('2d');\n        this.white = 'rgba(255,255,255,1)';\n        this.black = 'rgba(0,0,0,1)';\n        this.green = 'rgba(0,255,0,1)';\n        this.gray = 'rgba(128,128,128,1)';\n        this.orange = 'rgba(255,127,0,1)';\n        this.yellow = 'rgba(255,255,0,1)';\n        this.lightBlue = 'rgba(100,100,255,1)';\n        this.gridCellWidth = 20;\n    }\n    get thinLineWidth() {\n        return this.gridCellWidth * 0.1;\n    }\n    get mediumLineWidth() {\n        return this.gridCellWidth * 0.5;\n    }\n    get wideLineWidth() {\n        return this.gridCellWidth;\n    }\n    clearTheCanvas() {\n        this.canvasCtx.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);\n    }\n    paintLineBetweenCells(cell1, cell2, width = this.thinLineWidth, color = this.black, offset = false) {\n        let shadowOffset = 0;\n        if (offset) {\n            shadowOffset = this.gridCellWidth * 0.1;\n        }\n        this.canvasCtx.strokeStyle = color;\n        const centerOfCell1 = this.centerOfCell(cell1);\n        const centerOfCell2 = this.centerOfCell(cell2);\n        this.canvasCtx.lineWidth = width;\n        this.canvasCtx.lineCap = 'round';\n        this.canvasCtx.beginPath();\n        this.canvasCtx.moveTo(centerOfCell1.x + shadowOffset, centerOfCell1.y + shadowOffset);\n        this.canvasCtx.lineTo(centerOfCell2.x + shadowOffset, centerOfCell2.y + shadowOffset);\n        this.canvasCtx.stroke();\n    }\n    paintCellsAsHollowDots(cells, innerColor) {\n        this.paintCircles(cells, this.black, this.gridCellWidth * 0.64, false);\n        this.paintCircles(cells, innerColor, this.gridCellWidth * 0.4, false);\n    }\n    paintCircles(cells, color, diameter = this.gridCellWidth, offset = false) {\n        let shadowOffset = 0;\n        if (offset) {\n            shadowOffset = this.gridCellWidth * 0.1;\n        }\n        const radius = diameter / 2;\n        this.canvasCtx.fillStyle = color;\n        cells.forEach(cell => {\n            const center = this.centerOfCell(cell);\n            this.canvasCtx.beginPath();\n            this.canvasCtx.arc(center.x + shadowOffset, center.y + shadowOffset, radius, 0, 2 * Math.PI);\n            this.canvasCtx.fill();\n        });\n    }\n    paintSquares(cells, color) {\n        const padding = 1;\n        this.canvasCtx.fillStyle = color;\n        this.canvasCtx.beginPath(); //varför måste jag ha med detta för att färgändring ska slå igenom\n        this.canvasCtx.stroke(); // dito\n        const squareWidth = this.gridCellWidth - 2 * padding;\n        cells.forEach(cell => {\n            const corner = this.upperLeftCornerOfCell(cell);\n            this.canvasCtx.rect(corner.x + padding, corner.y + padding, squareWidth, squareWidth);\n            this.canvasCtx.fill();\n        });\n    }\n    upperLeftCornerOfCell(cell) {\n        const xPart = cell.columnIndex * this.gridCellWidth;\n        const yPart = cell.rowIndex * this.gridCellWidth;\n        return new Coordinate(xPart, yPart);\n    }\n    centerOfCell(cell) {\n        const xPart = cell.columnIndex * this.gridCellWidth + this.gridCellWidth / 2;\n        const yPart = cell.rowIndex * this.gridCellWidth + this.gridCellWidth / 2;\n        return new Coordinate(xPart, yPart);\n    }\n}\n","import { CanvasPainter } from './canvaspainter';\nexport class CellAgePainter extends CanvasPainter {\n    plotCells(grid) {\n        grid.allLiveCells.forEach(cell => {\n            this.paintSquares([cell], this.colorGivenTheAgeOfCell(cell));\n        });\n    }\n    colorGivenTheAgeOfCell(cell) {\n        switch (cell.age) {\n            case 1: return 'rgba(170,190,170,1)';\n            case 2: return 'rgba(150,170,150,1)';\n            case 3: return 'rgba(120,130,120,1)';\n            case 4: return 'rgba(90,110,90,1)';\n            case 5: return 'rgba(70,90,70,1)';\n            case 6: return 'rgba(50,70,50,1)';\n            case 7: return 'rgba(30,50,30,1)';\n            case 8: return 'rgba(10,30,10,1)';\n            default: return 'rgba(0,0,0,1)';\n        }\n    }\n}\n","import { CellAgePainter } from './cellagepainter';\nimport { CircularCellPainter } from './circularcellpainter';\nimport { ClassicCellPainter } from './classiccellpainter';\nimport { MoleculePainter } from './moleculepainter';\nimport { RibbonPainter } from './ribbonpainter';\nimport { NeighboursCountPainter } from './neighbourcountpainter';\nimport { SmoothCellPainter } from './smoothpainter';\n//TODO: döpa om till factory?\nexport class CellPainterProvider {\n    static getCellPainter(painterType) {\n        switch (painterType) {\n            case 'circular': return new CircularCellPainter();\n            case 'smooth': return new SmoothCellPainter();\n            case 'age': return new CellAgePainter();\n            case 'neighbours': return new NeighboursCountPainter();\n            case 'ribbon': return new RibbonPainter();\n            case 'molecule': return new MoleculePainter();\n            default: return new ClassicCellPainter();\n        }\n    }\n}\n","import { CanvasPainter } from './canvaspainter';\nexport class CircularCellPainter extends CanvasPainter {\n    plotCells(grid) {\n        this.paintCircles(grid.allLiveCells, this.black);\n    }\n}\n","import { CanvasPainter } from './canvaspainter';\nexport class ClassicCellPainter extends CanvasPainter {\n    plotCells(grid) {\n        this.paintSquares(grid.allLiveCells, this.black);\n    }\n}\n","import { CanvasPainter } from './canvaspainter';\nexport class MoleculePainter extends CanvasPainter {\n    plotCells(grid) {\n        const livingCells = grid.allLiveCells;\n        //orthogonal connections\n        livingCells\n            .forEach(cell => {\n            cell.livingOrthogonalNeighbours\n                .forEach(neighbour => {\n                this.paintLineBetweenCells(cell, neighbour);\n            });\n        });\n        this.cellsWithNoLivingOrthogonalNeihbours(livingCells)\n            .forEach(cell => {\n            cell.livingDiagonalNeighbours\n                .forEach(neighbour => {\n                this.paintLineBetweenCells(cell, neighbour);\n            });\n        });\n        this.cellsWithOneLivingOrthogonalNeihbours(livingCells).forEach(cell => {\n            cell.livingDiagonalNeighbours\n                .forEach(neighbour => {\n                if (this.cellsHaveNoCommonLivingOrthogonalNeighbours(cell, neighbour)) {\n                    this.paintLineBetweenCells(cell, neighbour);\n                }\n            });\n        });\n        this.paintCellsAsHollowDots(livingCells, this.gray);\n        this.paintCellsAsHollowDots(this.cellsWithNoLivingNeighbours(livingCells), this.yellow);\n        this.paintCellsAsHollowDots(this.cellsWithOneLivingOrthogonalNeighbour(livingCells), this.green);\n        this.cellsWithOneLivingOrthogonalNeihbours(livingCells).forEach(cell => {\n            cell.livingDiagonalNeighbours\n                .forEach(neighbour => {\n                if (this.cellsHaveNoCommonLivingOrthogonalNeighbours(cell, neighbour)) {\n                    this.paintCellsAsHollowDots([cell, neighbour], this.gray);\n                }\n            });\n        });\n        this.paintCellsAsHollowDots(this.cellsWithOneLivingDiagonalNeighbour(livingCells), this.lightBlue);\n        this.paintCellsAsHollowDots(this.cellsWithTwoDiagonalNeighboursNotOnALine(livingCells), this.orange);\n        this.paintCellsAsHollowDots(this.cellsWithTwoOrthogonalNeighbousNotOnALine(livingCells), this.orange);\n    }\n    cellsWithTwoOrthogonalNeighbousNotOnALine(cells) {\n        return cells\n            .filter(cell => cell.livingNeighbours.length == 2)\n            .filter(cell => cell.livingOrthogonalNeighbours.length == 2)\n            .filter(cell => {\n            const neighbours = cell.livingOrthogonalNeighbours;\n            const n1 = neighbours[0];\n            const n2 = neighbours[1];\n            return n1.columnIndex !== n2.columnIndex && n1.rowIndex !== n2.rowIndex;\n        });\n    }\n    cellsWithTwoDiagonalNeighboursNotOnALine(cells) {\n        return cells\n            .filter(cell => cell.livingNeighbours.length == 2)\n            .filter(cell => cell.livingDiagonalNeighbours.length == 2)\n            .filter(cell => {\n            const neighbours = cell.livingDiagonalNeighbours;\n            const n1 = neighbours[0];\n            const n2 = neighbours[1];\n            return n1.columnIndex == n2.columnIndex || n1.rowIndex == n2.rowIndex;\n        });\n    }\n    cellsWithNoLivingNeighbours(cells) {\n        return cells.filter(cell => cell.livingNeighbours.length == 0);\n    }\n    cellsWithOneLivingOrthogonalNeighbour(cells) {\n        return cells\n            //.filter(cell => cell.livingNeighbours.length == 1)\n            .filter(cell => cell.livingOrthogonalNeighbours.length == 1);\n    }\n    cellsWithOneLivingDiagonalNeighbour(cells) {\n        return cells\n            .filter(cell => cell.livingNeighbours.length == 1)\n            .filter(cell => cell.livingDiagonalNeighbours.length == 1);\n    }\n    cellsHaveNoCommonLivingOrthogonalNeighbours(cell1, cell2) {\n        const commonLivingOrthogonalCells = cell1.livingOrthogonalNeighbours\n            .filter(c1 => cell2.livingOrthogonalNeighbours.some(c2 => c1 == c2));\n        return commonLivingOrthogonalCells.length == 0;\n    }\n    cellsWithNoLivingOrthogonalNeihbours(cells) {\n        return cells\n            .filter(cell => cell.livingOrthogonalNeighbours.length == 0);\n    }\n    cellsWithOneLivingOrthogonalNeihbours(cells) {\n        return cells\n            .filter(cell => cell.livingOrthogonalNeighbours.length == 1);\n    }\n}\n","import { CanvasPainter } from './canvaspainter';\nexport class NeighboursCountPainter extends CanvasPainter {\n    plotCells(grid) {\n        grid.allLiveCells.forEach(cell => {\n            this.paintSquares([cell], this.colorGivenNumberOfNeighboursToOfCell(cell));\n        });\n    }\n    colorGivenNumberOfNeighboursToOfCell(cell) {\n        switch (cell.livingNeighbours.length) {\n            case 0: return 'rgba(170,190,170,1)';\n            case 1: return 'rgba(150,170,150,1)';\n            case 2: return 'rgba(120,130,120,1)';\n            case 3: return 'rgba(90,110,90,1)';\n            case 4: return 'rgba(70,90,70,1)';\n            case 5: return 'rgba(50,70,50,1)';\n            case 6: return 'rgba(30,50,30,1)';\n            case 7: return 'rgba(10,30,10,1)';\n            default: return 'rgba(0,0,0,1)';\n        }\n    }\n}\n","import { CellConnection } from '../../model/cellconnection';\nimport { CanvasPainter } from './canvaspainter';\nexport class RibbonPainter extends CanvasPainter {\n    plotCells(grid) {\n        grid.clusters.forEach(cluster => {\n            const randomConnections = this.generateMazelikeRandomCellConnections(cluster);\n            randomConnections.forEach(connection => {\n                this.paintLineBetweenCells(connection.cell1, connection.cell2, this.mediumLineWidth, this.gray, true);\n                this.paintLineBetweenCells(connection.cell1, connection.cell2, this.mediumLineWidth, this.green);\n            });\n        });\n        const lonleyCells = grid.allLiveCells.filter(cell => cell.livingNeighbours.length == 0);\n        this.paintCircles(lonleyCells, this.gray, this.mediumLineWidth, true);\n        this.paintCircles(lonleyCells, this.green, this.mediumLineWidth, false);\n    }\n    generateMazelikeRandomCellConnections(cluster) {\n        const cellConnections = [];\n        const cellsToConnect = cluster.length;\n        const connectedCells = new Set();\n        const connectionTrail = [];\n        const startCell = radomCellInArray(cluster);\n        connectCell(startCell);\n        while (cellsToConnect > connectedCells.size) {\n            while (cellHasNoUnconnectedNeigbours(currentCell()) && connectedTrailNotEmpty()) {\n                stepBackwards();\n            }\n            const randomNeighbour = randomUnconnectedNeighbour(currentCell());\n            cellConnections.push(new CellConnection(currentCell(), randomNeighbour));\n            connectCell(randomNeighbour);\n        }\n        return cellConnections;\n        function currentCell() {\n            const currentCell = connectionTrail[connectionTrail.length - 1];\n            return currentCell;\n        }\n        function connectedTrailNotEmpty() {\n            return connectionTrail.length != 0;\n        }\n        function cellHasNoUnconnectedNeigbours(cell) {\n            return cell.livingNeighbours.every(neigbour => connectedCells.has(neigbour));\n        }\n        function stepBackwards() {\n            connectionTrail.pop();\n        }\n        function randomUnconnectedNeighbour(cell) {\n            const unvisitedNeighbours = cell.livingNeighbours\n                .filter(neighbour => !connectedCells.has(neighbour));\n            return radomCellInArray(unvisitedNeighbours);\n        }\n        function connectCell(cell) {\n            connectedCells.add(cell);\n            connectionTrail.push(cell);\n        }\n        function radomCellInArray(cells) {\n            return cells[Math.floor(Math.random() * cells.length)];\n        }\n    }\n}\n","import { CanvasPainter } from './canvaspainter';\nexport class SmoothCellPainter extends CanvasPainter {\n    plotCells(grid) {\n        const livingCells = grid.allLiveCells;\n        livingCells.forEach(livingCell => {\n            livingCell.livingNeighbours\n                .forEach(livingNeighbourCell => {\n                this.paintLineBetweenCells(livingCell, livingNeighbourCell, this.wideLineWidth);\n            });\n        });\n        livingCells.forEach(livingCell => {\n            livingCell.deadNeighbours\n                .filter(deadCell => deadCell.livingOrthogonalNeighbours.length >= 3)\n                .forEach(deadCell => {\n                this.paintCircles([deadCell], this.white);\n            });\n        });\n        this.paintCircles(livingCells, this.black);\n    }\n}\n","export class Coordinate {\n    constructor(x, y) {\n        this._x = x;\n        this._y = y;\n    }\n    get x() {\n        return this._x;\n    }\n    get y() {\n        return this._y;\n    }\n}\n","import { SmoothCellPainter } from './cellpainters/smoothpainter';\nexport class View {\n    constructor() {\n        this._cellPainter = new SmoothCellPainter();\n    }\n    set cellPainter(cellPainter) {\n        this._cellPainter = cellPainter;\n    }\n    redrawGrid(grid) {\n        this._cellPainter.clearTheCanvas();\n        this._cellPainter.plotCells(grid);\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import './style.css';\nimport { Grid } from './model/grid';\nimport { View } from './view/view';\nimport { CellPainterProvider } from './view/cellpainters/cellpainterprovider';\nimport { Coordinate } from './view/coordinate';\nconst grid = new Grid(60, 55);\nconst view = new View();\n//Glider\ngrid.cellAt(15, 1).live();\ngrid.cellAt(15, 2).live();\ngrid.cellAt(15, 3).live();\ngrid.cellAt(16, 3).live();\ngrid.cellAt(17, 2).live();\n//Toad\ngrid.cellAt(4, 3).live();\ngrid.cellAt(5, 3).live();\ngrid.cellAt(6, 3).live();\ngrid.cellAt(5, 4).live();\ngrid.cellAt(6, 4).live();\ngrid.cellAt(7, 4).live();\n//corner\ngrid.cellAt(0, 0).live();\ngrid.cellAt(59, 54).live();\n//xxx\ngrid.cellAt(30, 27).live();\ngrid.cellAt(30, 28).live();\ngrid.cellAt(30, 29).live();\ngrid.cellAt(31, 26).live();\ngrid.cellAt(32, 26).live();\ngrid.cellAt(33, 27).live();\ngrid.cellAt(32, 28).live();\nfunction evolveAndPaint() {\n    grid.evolve();\n    view.redrawGrid(grid);\n}\nfunction changeCellPainter(cellPaintertype) {\n    view.cellPainter = CellPainterProvider.getCellPainter(cellPaintertype);\n    view.redrawGrid(grid);\n}\nfunction canvasLeftClicked(event, canvasId) {\n    const coordinate = getMouseCoordinate(event, canvasId);\n    grid.cellAt(Math.floor(coordinate.x / 20), Math.floor(coordinate.y / 20)).toggleLifeDeath();\n    view.redrawGrid(grid);\n}\nfunction getMouseCoordinate(event, elementId) {\n    const rect = document.getElementById(elementId).getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    return new Coordinate(x, y);\n}\nfunction killAll() {\n    const reallyKillAll = confirm('Do you want to kill every cell?');\n    if (reallyKillAll) {\n        grid.killAll();\n        view.redrawGrid(grid);\n    }\n}\nfunction keyPressed(event) {\n    switch (event.key) {\n        case 'e':\n            evolveAndPaint();\n            break;\n        case 'r':\n            changeCellPainter('ribbon');\n            break;\n        case 'a':\n            changeCellPainter('age');\n            break;\n        case 's':\n            changeCellPainter('smooth');\n            break;\n        case 'd':\n            changeCellPainter('circular');\n            break;\n        case 'f':\n            changeCellPainter('molecule');\n            break;\n        case 'x':\n            killAll();\n            break;\n        case 'c':\n            changeCellPainter('classic');\n            break;\n        case 'v':\n            changeCellPainter('neighbours');\n            break;\n    }\n}\ndocument.getElementById('evolveButton').addEventListener('click', () => evolveAndPaint());\ndocument.getElementById('classicButton').addEventListener('click', () => changeCellPainter('classic'));\ndocument.getElementById('circularButton').addEventListener('click', () => changeCellPainter('circular'));\ndocument.getElementById('smoothButton').addEventListener('click', () => changeCellPainter('smooth'));\ndocument.getElementById('cellAgeButton').addEventListener('click', () => changeCellPainter('age'));\ndocument.getElementById('neigbourcountButton').addEventListener('click', () => changeCellPainter('neighbours'));\ndocument.getElementById('ribbonButton').addEventListener('click', () => changeCellPainter('ribbon'));\ndocument.getElementById('moleculeButton').addEventListener('click', () => changeCellPainter('molecule'));\ndocument.getElementById('killAllButton').addEventListener('click', () => killAll());\ndocument.getElementById('myCanvas')\n    .addEventListener('click', (event) => canvasLeftClicked(event, event.target.id));\ndocument.addEventListener('keydown', (event) => keyPressed(event));\n"],"names":[],"sourceRoot":""}