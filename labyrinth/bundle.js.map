{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;;;;;ACAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACPO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;;;;;;;;;;;;;;ACjEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/C8B;AACA;AACvB,4BAA4B,uCAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC;AACtE;AACA,mCAAmC,8BAA8B;AACjE;AACA;AACA;AACA;AACA;AACA,oCAAoC,uCAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sCAAsC;AACrE,sCAAsC,+CAA+C;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kCAAkC;AACjE,sCAAsC,+CAA+C;AACrF;AACA;AACA;AACA;AACA,uCAAuC,iCAAiC;AACxE;AACA;AACA;AACA;AACA;AACA,6BAA6B,uCAAuC;AACpE;AACA,8BAA8B,iCAAiC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2BAA2B;AAC7D,mCAAmC,qCAAqC;AACxE;AACA;AACA;AACA;AACA;AACA,kCAAkC,+BAA+B;AACjE,mCAAmC,qCAAqC;AACxE;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3FO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;AC3E8B;AACA;AACvB,8BAA8B,uCAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC;AACtE;AACA,mCAAmC,8BAA8B;AACjE;AACA;AACA,oCAAoC,uCAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2BAA2B;AAC7D,mCAAmC,yCAAyC;AAC5E;AACA;AACA;AACA;AACA;AACA,kCAAkC,2BAA2B;AAC7D,mCAAmC,qCAAqC;AACxE;AACA;AACA;AACA;AACA;AACA,kCAAkC,2BAA2B;AAC7D,mCAAmC,qCAAqC;AACxE;AACA;AACA;AACA;AACA;AACA,kCAAkC,+BAA+B;AACjE,mCAAmC,qCAAqC;AACxE;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1D8B;AACvB,wBAAwB,uCAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrB8B;AACvB,4BAA4B,uCAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7B8B;AACvB,0BAA0B,uCAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACfO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UC3CA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;ACNqB;AACqB;AACJ;AACoB;AACJ;AACL;AACJ;AACQ;AACrD,kBAAkB,+CAAK;AACvB,uBAAuB,mDAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mEAAe;AACpC,qBAAqB,sDAAS;AAC9B;AACA;AACA;AACA,qBAAqB,+DAAa;AAClC,qBAAqB,0DAAW;AAChC;AACA;AACA;AACA,qBAAqB,+DAAa;AAClC,qBAAqB,8DAAa;AAClC;AACA","sources":["webpack://typescript-browser-development-setup/./src/style.css?e320","webpack://typescript-browser-development-setup/./src/controller.ts","webpack://typescript-browser-development-setup/./src/model/cell.ts","webpack://typescript-browser-development-setup/./src/model/grid.ts","webpack://typescript-browser-development-setup/./src/model/hexagonalgrid.ts","webpack://typescript-browser-development-setup/./src/model/model.ts","webpack://typescript-browser-development-setup/./src/model/rectangulargrid.ts","webpack://typescript-browser-development-setup/./src/view/boxedview.ts","webpack://typescript-browser-development-setup/./src/view/honeycombview.ts","webpack://typescript-browser-development-setup/./src/view/roundedview.ts","webpack://typescript-browser-development-setup/./src/view/view.ts","webpack://typescript-browser-development-setup/webpack/bootstrap","webpack://typescript-browser-development-setup/webpack/runtime/define property getters","webpack://typescript-browser-development-setup/webpack/runtime/hasOwnProperty shorthand","webpack://typescript-browser-development-setup/webpack/runtime/make namespace object","webpack://typescript-browser-development-setup/./src/main.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","export class Controller {\n    constructor(model) {\n        this.model = model;\n    }\n    generateLabyrinth() {\n        this.model.generateLabyrinth();\n    }\n}\n","export class Cell {\n    constructor(x, y) {\n        this.hasBeenVisited = false;\n        this.neighbouringCells = [];\n        this._connectedNeighbouringCells = [];\n        this.xCoordinate = x;\n        this.yCoordinate = y;\n    }\n    get neighbours() {\n        return this.neighbouringCells;\n    }\n    get unvisitedNeighbours() {\n        return this.neighbouringCells.filter(cell => !cell.visited);\n    }\n    get hasNoUnvisitedNeighbours() {\n        return this.unvisitedNeighbours.length == 0;\n    }\n    get randomUnvisitedNeighbour() {\n        const randomIndex = Math.floor(Math.random() * this.unvisitedNeighbours.length);\n        return this.unvisitedNeighbours[randomIndex];\n    }\n    addNeighbour(cell) {\n        this.neighbouringCells.push(cell);\n    }\n    get visited() {\n        return this.hasBeenVisited;\n    }\n    set visited(visited) {\n        this.hasBeenVisited = visited;\n    }\n    get connectedNeighbouringCells() {\n        return this._connectedNeighbouringCells;\n    }\n    removeEstablishedConnections() {\n        this._connectedNeighbouringCells = [];\n    }\n    addConnection(toCell) {\n        this._connectedNeighbouringCells.push(toCell);\n    }\n    removeConnection(toCell) {\n        const index = this._connectedNeighbouringCells.indexOf(toCell);\n        if (index > -1) {\n            this._connectedNeighbouringCells.splice(index, 1);\n        }\n    }\n    interconnectToCell(cell) {\n        this.addConnection(cell);\n        cell.addConnection(this);\n    }\n    removeInterConnectionsToCell() {\n        const interConnectedCells = [...this.connectedNeighbouringCells];\n        interConnectedCells.forEach(otherCell => {\n            this.removeConnection(otherCell);\n            otherCell.removeConnection(this);\n        });\n    }\n    get x() {\n        return this.xCoordinate;\n    }\n    get y() {\n        return this.yCoordinate;\n    }\n    get centerCoordinate() {\n        return { x: this.xCoordinate, y: this.yCoordinate };\n    }\n}\n","export class Grid {\n    constructor(_numberOfColumns, _numberOfRows, _cellWidth) {\n        this._numberOfColumns = _numberOfColumns;\n        this._numberOfRows = _numberOfRows;\n        this._cellWidth = _cellWidth;\n        //\n    }\n    get numberOfColumns() {\n        return this._numberOfColumns;\n    }\n    get numberOfRows() {\n        return this._numberOfRows;\n    }\n    get cellWidth() {\n        return this._cellWidth;\n    }\n    get startCell() {\n        return this._startCell;\n    }\n    set startCell(cell) {\n        this._startCell = cell;\n    }\n    get endCell() {\n        return this._endCell;\n    }\n    set endCell(cell) {\n        this._endCell = cell;\n    }\n    get cellMatrix() {\n        return this._cellMatrix;\n    }\n    set cellMatrix(cellMatrix) {\n        this._cellMatrix = cellMatrix;\n    }\n    get totalNumberOfCells() {\n        return this._numberOfColumns * this._numberOfRows;\n    }\n    resetVisitedStatusOnCells() {\n        this._cellMatrix.flat().forEach(cell => cell.visited = false);\n        this.startCell.visited = true;\n    }\n    removeEstablishedConnectionsInCells() {\n        this._cellMatrix.flat().forEach(cell => cell.removeEstablishedConnections());\n    }\n    get numberOfVisitedCells() {\n        return this._cellMatrix.flat().filter(cell => cell.visited).length;\n    }\n}\n","import { Cell } from './cell';\nimport { Grid } from './grid';\nexport class HexagonalGrid extends Grid {\n    constructor(numberOfColumns, numberOfRows, cellWidth) {\n        super(numberOfColumns, numberOfRows, cellWidth);\n        this.cellMatrix = this.createMatrixOfInterconnectedHexagonalCells();\n        this.startCell = this.cellMatrix[0][0];\n        this.startCell.visited = true;\n        this.endCell = this.cellMatrix[this.numberOfColumns - 1][this.numberOfRows - 1];\n    }\n    get heightDistancing() {\n        return this.cellWidth * 3 / (2 * Math.sqrt(3));\n    }\n    get widthDistancing() {\n        return this.cellWidth;\n    }\n    get rowOffset() {\n        return this.cellWidth / 2;\n    }\n    createMatrixOfInterconnectedHexagonalCells() {\n        const grid = [];\n        for (let columnIndex = 0; columnIndex < this.numberOfColumns; columnIndex++) {\n            const rowOfCells = [];\n            for (let rowIndex = 0; rowIndex < this.numberOfRows; rowIndex++) {\n                let xCoordinate = this.widthDistancing + columnIndex * this.widthDistancing;\n                if (rowIndex % 2 == 1) {\n                    xCoordinate += this.rowOffset;\n                }\n                const yCoordinate = this.heightDistancing + rowIndex * this.heightDistancing;\n                rowOfCells.push(new Cell(xCoordinate, yCoordinate));\n            }\n            grid.push(rowOfCells);\n        }\n        this.interconnectGrid(grid);\n        return grid;\n    }\n    interconnectGrid(grid) {\n        this.connectNeighboursToTheSouth(grid);\n        this.connectNeighboursToTheNorth(grid);\n        this.connectNeighboursToTheWest(grid);\n        this.connectNeighboursToTheEast(grid);\n    }\n    connectNeighboursToTheSouth(grid) {\n        const transposedGrid = this.transposeArrayOfArrays(grid);\n        for (let rowIndex = 0; rowIndex < transposedGrid.length - 1; rowIndex++) {\n            for (let columnIndex = 0; columnIndex < transposedGrid[rowIndex].length; columnIndex++) {\n                const currentCell = transposedGrid[rowIndex][columnIndex];\n                const highestAcceptedDistance = this.widthDistancing * 0.55;\n                transposedGrid[rowIndex + 1]\n                    .filter(cell => (highestAcceptedDistance > Math.abs(currentCell.x - cell.x)))\n                    .forEach(cell => currentCell.addNeighbour(cell));\n            }\n        }\n    }\n    connectNeighboursToTheNorth(grid) {\n        const transposedGrid = this.transposeArrayOfArrays(grid);\n        for (let rowIndex = 1; rowIndex < transposedGrid.length; rowIndex++) {\n            for (let columnIndex = 0; columnIndex < transposedGrid[rowIndex].length; columnIndex++) {\n                const currentCell = transposedGrid[rowIndex][columnIndex];\n                const highestAcceptedDistance = this.widthDistancing * 0.55;\n                transposedGrid[rowIndex - 1]\n                    .filter(cell => (highestAcceptedDistance > Math.abs(currentCell.x - cell.x)))\n                    .forEach(cell => { currentCell.addNeighbour(cell); });\n            }\n        }\n    }\n    transposeArrayOfArrays(inputArrayOfArrays) {\n        const newArrayOfArrays = [];\n        for (let column = 0; column < inputArrayOfArrays[0].length; column++) {\n            const newRow = [];\n            for (let row = 0; row < inputArrayOfArrays.length; row++) {\n                newRow.push(inputArrayOfArrays[row][column]);\n            }\n            newArrayOfArrays.push(newRow);\n        }\n        return newArrayOfArrays;\n    }\n    connectNeighboursToTheWest(grid) {\n        for (let columnIndex = 1; columnIndex < grid.length; columnIndex++) {\n            for (let rowIndex = 0; rowIndex < grid[columnIndex].length; rowIndex++) {\n                grid[columnIndex][rowIndex].addNeighbour(grid[columnIndex - 1][rowIndex]);\n            }\n        }\n    }\n    connectNeighboursToTheEast(grid) {\n        for (let columnIndex = 0; columnIndex < grid.length - 1; columnIndex++) {\n            for (let rowIndex = 0; rowIndex < grid[columnIndex].length; rowIndex++) {\n                grid[columnIndex][rowIndex].addNeighbour(grid[columnIndex + 1][rowIndex]);\n            }\n        }\n    }\n}\n","export class Model {\n    constructor() {\n        this._sequenceOfVisitedCells = [];\n        this._solutionSequence = [];\n    }\n    set grid(grid) {\n        this._grid = grid;\n    }\n    set view(view) {\n        this._view = view;\n    }\n    get visitedStackIsNotEmpty() {\n        return this._sequenceOfVisitedCells.length != 0;\n    }\n    get currentCell() {\n        return this._sequenceOfVisitedCells[this._sequenceOfVisitedCells.length - 1];\n    }\n    initialize() {\n        this._view.clearTheCanvas();\n        this._grid.resetVisitedStatusOnCells();\n        this._grid.removeEstablishedConnectionsInCells();\n        this._sequenceOfVisitedCells = [this._grid.startCell];\n        this._solutionSequence = [];\n    }\n    generateLabyrinth() {\n        this.initialize();\n        let numberOfVisitedCells = this._grid.numberOfVisitedCells;\n        while (this._grid.totalNumberOfCells > numberOfVisitedCells) {\n            while (this.currentCell.hasNoUnvisitedNeighbours && this.visitedStackIsNotEmpty) {\n                this.stepBackwards();\n            }\n            this.stepToUnvisitedNeighbour();\n            numberOfVisitedCells++;\n        }\n    }\n    stepToUnvisitedNeighbour() {\n        const nextCell = this.currentCell.randomUnvisitedNeighbour;\n        nextCell.visited = true;\n        this.currentCell.interconnectToCell(nextCell);\n        this._view.drawConnection(this.currentCell.centerCoordinate, nextCell.centerCoordinate);\n        this._sequenceOfVisitedCells.push(nextCell);\n        if (nextCell === this._grid.endCell) {\n            this._solutionSequence = [...this._sequenceOfVisitedCells];\n        }\n    }\n    stepBackwards() {\n        this._sequenceOfVisitedCells.pop();\n    }\n    showSolution() {\n        for (let index = 0; index < this._solutionSequence.length - 1; index++) {\n            const currentCell = this._solutionSequence[index];\n            const nextCell = this._solutionSequence[index + 1];\n            this._view.drawTrail(currentCell.centerCoordinate, nextCell.centerCoordinate);\n        }\n    }\n    hideSolution() {\n        for (let index = 0; index < this._solutionSequence.length - 1; index++) {\n            const currentCell = this._solutionSequence[index];\n            const nextCell = this._solutionSequence[index + 1];\n            this._view.concealTrail(currentCell.centerCoordinate, nextCell.centerCoordinate);\n        }\n    }\n    reduceSomeComplexity() {\n        if (!this._grid) {\n            return;\n        }\n        this._grid.cellMatrix.flat()\n            .filter(cell => cell.connectedNeighbouringCells.length == 1)\n            .filter(cell => cell != this._grid.startCell)\n            .filter(cell => cell != this._grid.endCell)\n            .forEach(cell => {\n            cell.removeInterConnectionsToCell();\n            this._view.fillCell(cell.centerCoordinate);\n        });\n    }\n}\n","import { Cell } from './cell';\nimport { Grid } from './grid';\nexport class RectangularGrid extends Grid {\n    constructor(numberOfColumns, numberOfRows, cellWidth) {\n        super(numberOfColumns, numberOfRows, cellWidth);\n        this.cellMatrix = this.createMatrixOfInterconnectedSquareCells();\n        this.startCell = this.cellMatrix[0][0];\n        this.startCell.visited = true;\n        this.endCell = this.cellMatrix[this.numberOfColumns - 1][this.numberOfRows - 1];\n    }\n    createMatrixOfInterconnectedSquareCells() {\n        const grid = [];\n        for (let columnIndex = 0; columnIndex < this.numberOfColumns; columnIndex++) {\n            const rowOfCells = [];\n            for (let rowIndex = 0; rowIndex < this.numberOfRows; rowIndex++) {\n                const xCoordinate = this.cellWidth + columnIndex * this.cellWidth;\n                const yCoordinate = this.cellWidth + rowIndex * this.cellWidth;\n                rowOfCells.push(new Cell(xCoordinate, yCoordinate));\n            }\n            grid.push(rowOfCells);\n        }\n        this.interconnectGrid(grid);\n        return grid;\n    }\n    interconnectGrid(grid) {\n        this.connectNeighboursToTheSouth(grid);\n        this.connectNeighboursToTheNorth(grid);\n        this.connectNeighboursToTheWest(grid);\n        this.connectNeighboursToTheEast(grid);\n    }\n    connectNeighboursToTheSouth(grid) {\n        for (let columnIndex = 0; columnIndex < grid.length; columnIndex++) {\n            for (let rowIndex = 0; rowIndex < grid[columnIndex].length - 1; rowIndex++) {\n                grid[columnIndex][rowIndex].addNeighbour(grid[columnIndex][rowIndex + 1]);\n            }\n        }\n    }\n    connectNeighboursToTheNorth(grid) {\n        for (let columnIndex = 0; columnIndex < grid.length; columnIndex++) {\n            for (let rowIndex = 1; rowIndex < grid[columnIndex].length; rowIndex++) {\n                grid[columnIndex][rowIndex].addNeighbour(grid[columnIndex][rowIndex - 1]);\n            }\n        }\n    }\n    connectNeighboursToTheWest(grid) {\n        for (let columnIndex = 1; columnIndex < grid.length; columnIndex++) {\n            for (let rowIndex = 0; rowIndex < grid[columnIndex].length; rowIndex++) {\n                grid[columnIndex][rowIndex].addNeighbour(grid[columnIndex - 1][rowIndex]);\n            }\n        }\n    }\n    connectNeighboursToTheEast(grid) {\n        for (let columnIndex = 0; columnIndex < grid.length - 1; columnIndex++) {\n            for (let rowIndex = 0; rowIndex < grid[columnIndex].length; rowIndex++) {\n                grid[columnIndex][rowIndex].addNeighbour(grid[columnIndex + 1][rowIndex]);\n            }\n        }\n    }\n}\n","import { View } from './view';\nexport class BoxedView extends View {\n    constructor(width) {\n        super();\n        this.width = width;\n    }\n    drawConnection(startPoint, endPoint) {\n        this.canvasCtx.strokeStyle = 'rgba(255,255,255,1)';\n        this.canvasCtx.lineWidth = this.width;\n        this.canvasCtx.lineCap = 'square';\n        this.canvasCtx.beginPath();\n        this.canvasCtx.moveTo(startPoint.x, startPoint.y);\n        this.canvasCtx.lineTo(endPoint.x, endPoint.y);\n        this.canvasCtx.stroke();\n    }\n    fillCell(center) {\n        this.canvasCtx.fillStyle = 'rgba(0,0,0,1)';\n        const squareWidth = this.width + 1;\n        this.canvasCtx.rect(center.x - squareWidth / 2, center.y - squareWidth / 2, squareWidth, squareWidth);\n        this.canvasCtx.fill();\n    }\n}\n","import { View } from './view';\nexport class HoneycombView extends View {\n    constructor(width) {\n        super();\n        this.width = width;\n    }\n    drawConnection(startPoint, endPoint) {\n        this.drawFilledHexagon(startPoint, this.width, this.mazeColor);\n        this.drawFilledHexagon(endPoint, this.width, this.mazeColor);\n        const quarterHeight = this.width / Math.sqrt(3) / 2;\n        this.drawLine(startPoint, endPoint, quarterHeight * 2, this.mazeColor);\n    }\n    drawFilledHexagon(center, width, color) {\n        const halfWidth = width / 2;\n        const quarterHeight = width / Math.sqrt(3) / 2;\n        this.canvasCtx.fillStyle = color;\n        this.canvasCtx.beginPath();\n        this.canvasCtx.moveTo(center.x + halfWidth, center.y + quarterHeight);\n        this.canvasCtx.lineTo(center.x, center.y + 2 * quarterHeight);\n        this.canvasCtx.lineTo(center.x - halfWidth, center.y + quarterHeight);\n        this.canvasCtx.lineTo(center.x - halfWidth, center.y - quarterHeight);\n        this.canvasCtx.lineTo(center.x, center.y - 2 * quarterHeight);\n        this.canvasCtx.lineTo(center.x + halfWidth, center.y - quarterHeight);\n        this.canvasCtx.closePath();\n        this.canvasCtx.fill();\n    }\n    fillCell(center) {\n        this.drawFilledHexagon(center, this.width + 3, 'rgba(0,0,0,1)');\n    }\n}\n","import { View } from './view';\nexport class RoundedView extends View {\n    constructor(width) {\n        super();\n        this.width = width;\n    }\n    drawConnection(startPoint, endPoint) {\n        this.drawLine(startPoint, endPoint, this.width, this.mazeColor);\n    }\n    fillCell(center) {\n        this.canvasCtx.fillStyle = 'rgba(0,0,0,1)';\n        this.canvasCtx.beginPath();\n        this.canvasCtx.arc(center.x, center.y, (this.width + 3) / 2, 0, 2 * Math.PI);\n        this.canvasCtx.fill();\n    }\n}\n","export class View {\n    constructor() {\n        this.canvasElement = document.getElementById('myCanvas');\n        this.canvasCtx = this.canvasElement.getContext('2d');\n        this.mazeColor = 'rgba(255,255,255,1)';\n        this.trailColor = 'rgba(0,0,255,1)';\n    }\n    clearTheCanvas() {\n        this.canvasCtx.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);\n    }\n    paintCellCenter(centerPoint) {\n        this.canvasCtx.fillStyle = this.mazeColor;\n        this.canvasCtx.beginPath();\n        this.canvasCtx.arc(centerPoint.x, centerPoint.y, 3, 0, 2 * Math.PI);\n        this.canvasCtx.fill();\n    }\n    drawTrail(startPoint, endPoint) {\n        this.canvasCtx.strokeStyle = this.trailColor;\n        this.canvasCtx.lineWidth = 2;\n        this.canvasCtx.lineCap = 'round';\n        this.canvasCtx.beginPath();\n        this.canvasCtx.moveTo(startPoint.x, startPoint.y);\n        this.canvasCtx.lineTo(endPoint.x, endPoint.y);\n        this.canvasCtx.stroke();\n    }\n    concealTrail(startPoint, endPoint) {\n        this.canvasCtx.strokeStyle = this.mazeColor;\n        this.canvasCtx.lineWidth = 4;\n        this.canvasCtx.lineCap = 'round';\n        this.canvasCtx.beginPath();\n        this.canvasCtx.moveTo(startPoint.x, startPoint.y);\n        this.canvasCtx.lineTo(endPoint.x, endPoint.y);\n        this.canvasCtx.stroke();\n    }\n    drawLine(fromPoint, toPoint, width, color) {\n        this.canvasCtx.strokeStyle = color;\n        this.canvasCtx.lineWidth = width;\n        this.canvasCtx.lineCap = 'round';\n        this.canvasCtx.beginPath();\n        this.canvasCtx.moveTo(fromPoint.x, fromPoint.y);\n        this.canvasCtx.lineTo(toPoint.x, toPoint.y);\n        this.canvasCtx.stroke();\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import './style.css';\nimport { Controller } from './controller';\nimport { Model } from './model/model';\nimport { RectangularGrid } from './model/rectangulargrid';\nimport { HexagonalGrid } from './model/hexagonalgrid';\nimport { RoundedView } from './view/roundedview';\nimport { BoxedView } from './view/boxedview';\nimport { HoneycombView } from './view/honeycombview';\nconst model = new Model();\nconst controller = new Controller(model);\ndocument.getElementById('squareMazeButton').addEventListener('click', () => createSquareMaze());\ndocument.getElementById('roundedMazeButton').addEventListener('click', () => createRoundedMaze());\ndocument.getElementById('hexagonalMazeButton').addEventListener('click', () => createHexagonalMaze());\ndocument.getElementById('simplifyButton').addEventListener('click', () => model.reduceSomeComplexity());\ndocument.getElementById('showTrailButton').addEventListener('click', () => model.showSolution());\ndocument.getElementById('hideTrailButton').addEventListener('click', () => model.hideSolution());\nfunction createSquareMaze() {\n    model.grid = new RectangularGrid(69, 43, 15);\n    model.view = new BoxedView(14);\n    controller.generateLabyrinth();\n}\nfunction createRoundedMaze() {\n    model.grid = new HexagonalGrid(51, 37, 20);\n    model.view = new RoundedView(16);\n    controller.generateLabyrinth();\n}\nfunction createHexagonalMaze() {\n    model.grid = new HexagonalGrid(51, 37, 20);\n    model.view = new HoneycombView(18);\n    controller.generateLabyrinth();\n}\n"],"names":[],"sourceRoot":""}